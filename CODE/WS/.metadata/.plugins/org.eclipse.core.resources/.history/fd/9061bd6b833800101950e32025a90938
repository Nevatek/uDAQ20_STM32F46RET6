/*
 * USB_CDC.c
 *
 *  Created on: Jan 10, 2025
 *      Author: aldri
 */
#include "main.h"
#include "usb_device.h"
#include "usbd_cdc_if.h"
#include "USB_CDC.h"
#include "../Library/Convert.h"
#include "../Library/lwgps/src/include/lwgps/lwgps.h"
#include "GNSS.h"
#include "../Library/lsm6ds3tr-c/lsm6ds3tr-c_reg.h"
#include "Application.h"
#include "NVM.h"

static USB_CDC_CMD_FORMAT m_cdcData;
static void USB_CDC_ProcessRxCommand(USB_CDC_CMD_FORMAT *pcdcData);
static uint8_t USB_CDC_ParseRxBuffer(uint8_t*pBuff , uint32_t u32Len);

/*
 * Callback function to notify the RX buffer is received over USB CDC.
 */
void USB_CDC_RxHandler(uint8_t* Buf, uint32_t Len)
{
	USB_CDC_ParseRxBuffer(Buf , (Len <= sizeof(USB_CDC_CMD_FORMAT) + sizeof(uint16_t))?Len:sizeof(USB_CDC_CMD_FORMAT));
}
/*
 * Function to transmit a data buffer to usb cdc.
 */
void USB_CDC_Transmit(uint8_t* Buf, uint32_t Len)
{
	CDC_Transmit_FS(Buf, Len);
}
/*
 * Function to transmit a response to PC application.
 */
void USB_CDC_Transmit_Response(uint8_t u8CMD, uint8_t *pData , uint16_t u16Len)
{
	uint16_t u16Crc = 0U;
	USB_CDC_CMD_FORMAT m_TxcdcData;
	uint8_t arrTxBuff[sizeof(uint16_t) + sizeof(USB_CDC_CMD_FORMAT)] = {0x00};
	memset(&m_TxcdcData , 0u , sizeof(m_TxcdcData));

	m_TxcdcData.u8SOP1 = USB_CDC_SOP1;
	m_TxcdcData.u8SOP2 = USB_CDC_SOP2;
	m_TxcdcData.u8SOP3 = USB_CDC_SOP3;

	m_TxcdcData.u8CMD = u8CMD;
	m_TxcdcData.u8Datelength = ((u16Len <= USB_CDC_MAX_LENGTH_OF_DATA_PACKET)?u16Len:USB_CDC_MAX_LENGTH_OF_DATA_PACKET);

	if(NULL != pData && u16Len)
	{
		memcpy(&m_TxcdcData.u8DATA[0U] , pData , (u16Len <= USB_CDC_MAX_LENGTH_OF_DATA_PACKET)?u16Len:USB_CDC_MAX_LENGTH_OF_DATA_PACKET);
	}
	u16Crc = APP_CalculateCRC((uint8_t*)&m_TxcdcData , sizeof(m_TxcdcData));
	memcpy(arrTxBuff , (uint8_t*)&m_TxcdcData , sizeof(m_TxcdcData));/*Copy CRC*/
	memcpy((uint8_t*)&arrTxBuff[u16Len + 6U/*Num of bytes before data*/] , &u16Crc , sizeof(uint16_t));/*Copy CRC*/
	USB_CDC_Transmit((uint8_t*)&arrTxBuff[0U] , u16Len + 6U + sizeof(uint16_t)/*CRC*/);
}
/*
 * Funtion to parse recieved commands
 *SOP1 - 0
 *SOP2 - 1
 *SOP3 - 2
 *1Byte Cmd - 3
 *2 Byte Len - 4
 *DATA - 6
 *2Byte CRC
 *EOP
 */
uint8_t USB_CDC_ParseRxBuffer(uint8_t*pBuff , uint32_t u32Len)
{

	uint16_t u16ReadCrc = 0U;
	uint8_t u8Status = FALSE;

	if((sizeof(USB_CDC_CMD_FORMAT) + sizeof(uint16_t)) < u32Len)
	{

		USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_INVALID_FRAME , NULL , 0U);
		return u8Status = FALSE;
	}

	memcpy(&m_cdcData , pBuff , sizeof(m_cdcData));
	if(USB_CDC_MAX_LENGTH_OF_DATA_PACKET < m_cdcData.u8Datelength)
	{

		USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_INVALID_PACKET , NULL , 0U);
		return u8Status = FALSE;
	}
	u16ReadCrc = pBuff[6U + m_cdcData.u8Datelength + 1U] << 8 | pBuff[6U + m_cdcData.u8Datelength];
	/*
	 * Validate Start of packet
	 */
	if(USB_CDC_SOP1 == m_cdcData.u8SOP1 &&
			USB_CDC_SOP2 == m_cdcData.u8SOP2 &&
			USB_CDC_SOP3 == m_cdcData.u8SOP3)
	{
		/*
		 * Calculate and validate CRC
		 */
		if(1 || u16ReadCrc == APP_CalculateCRC((uint8_t*)&m_cdcData , sizeof(USB_CDC_CMD_FORMAT) - 2))
		{
			/*
			 * Validate Commands
			 */
			USB_CDC_ProcessRxCommand((USB_CDC_CMD_FORMAT*)&m_cdcData);
		}
		else
		{
			/*Checksum failed*/
			u8Status = FALSE;
			USB_CDC_Transmit_Response(USB_CDC_RESP_CRC_FAILED , NULL , 0U);
		}
	}
	else
	{
		u8Status = FALSE;
		USB_CDC_Transmit_Response(USB_CDC_RESP_SOP_FAILED , NULL , 0U);
	}
	return u8Status;
}
/*
 * Function to process recieved commands
 */
void USB_CDC_ProcessRxCommand(USB_CDC_CMD_FORMAT *pcdcData)
{
	SETTINGS *pSetting = getInstance_Settings();
	uint8_t u8Status = FALSE;
	/*
	 * Validate Commands
	 */
	switch(m_cdcData.u8CMD)
	{
		case (USB_CDC_CMD_PING):
		{
			USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
		}break;
		case (USB_CDC_CMD_RESET_DEV):
		{
			USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
			HAL_Delay(100U);
			HAL_NVIC_SystemReset();
		}break;
		case (USB_CDC_CMD_GET_DEV_MODE):
		{
			USB_CDC_Transmit_Response(USB_CDC_RESP_GET_DEV_MODE , &pSetting->u8DevMode , 1U);
		}break;

		case (USB_CDC_CMD_SET_DEV_MODE):
		{
			if(MODE_NORMAL_MEASUREMENT == pcdcData->u8DATA[0])
			{
				App_SetDevMode_StartDataAqucission();
			}
			else
			{
				App_SetDevMode_Idle();
			}
#if 0/*If saving of existing state is required.*/
			NVM_WriteSettings();
#endif
			USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
		}break;

		case (USB_CDC_CMD_GET_SETTINGS):
		{
			USB_CDC_Transmit_Response(USB_CDC_RESP_GET_SETTINGS , (uint8_t*)pSetting , sizeof(SETTINGS));
		}break;

		case (USB_CDC_CMD_SET_SETTINGS):
		{
			memcpy(pSetting , &pcdcData->u8DATA[0] , sizeof(SETTINGS));
			NVM_WriteSettings();
			USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
		}break;

		case (USB_CDC_CMD_RESET_SETTINGS):
		{
			NVM_ResetMemory();
			NVM_WriteSettings();
			USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
		}break;
		case (USB_CDC_CMD_ERASE_WHOLE_CHIP):
		{
			if(TRUE == NVM_EraseFullChip())
			{
				USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
			}
			else
			{
				USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_FLASH_ERASE , NULL , 0U);
			}

		}break;
		case (USB_CDC_CMD_GET_DB_COUNT):
		{
			uint32_t u32DBCnt = Get_DBCountValue();
			USB_CDC_Transmit_Response(USB_CDC_RESP_GET_DB_COUNT , (uint8_t*)&u32DBCnt , sizeof(u32DBCnt));
		}break;
		case (USB_CDC_CMD_CLEAR_DB_COUNT):
		{
			if(MODE_DEV_IDLE == pSetting->u8DevMode)
			{
				NVM_ResetDBCount();
				NVM_ResetDBFifo();
				USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
			}
			else
			{
				USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_NOT_IDLE , NULL , 0U);
			}
		}break;

		case (USB_CDC_CMD_ERASE_FLASH_BLOCKWISE):/*Total 256 block per chip*/
		{
			uint32_t u32FlashBlock = 0U;
			u32FlashBlock = pcdcData->u8DATA[3U] << 24U |  pcdcData->u8DATA[2U] << 16U |  pcdcData->u8DATA[1U] << 8U |  pcdcData->u8DATA[0U];
			if(MODE_DEV_IDLE == pSetting->u8DevMode)
			{
				u8Status = NVM_EraseFlashBlock(u32FlashBlock);
				if(TRUE == u8Status)
				{
					if(TRUE == NVM_VerifyFlashErase(u32FlashBlock))
					{
						USB_CDC_Transmit_Response(USB_CDC_RESP_OK , NULL , 0U);
					}
					else
					{
						USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_FLASH_ERASE_VERIFY , NULL , 0U);
					}
				}
				else
				{
					USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_FLASH_ERASE , NULL , 0U);
				}
			}
			else
			{
				USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_NOT_IDLE , NULL , 0U);
			}
		}break;
		case (USB_CDC_CMD_GET_DB_DATA):
		{
			DATABASE m_DB[MAX_DATA_PER_DATAPUSH_CYCLE];
			uint32_t u32SectorCnt = 0U;
			u32SectorCnt = pcdcData->u8DATA[3U] << 24U |  pcdcData->u8DATA[2U] << 16U |  pcdcData->u8DATA[1U] << 8U |  pcdcData->u8DATA[0U];
			memset(&m_DB[0U] , 0U , sizeof(m_DB));
			if(MODE_DEV_IDLE == pSetting->u8DevMode)
			{
				if(TRUE == NVM_Read_DataBase((DATABASE*)&m_DB[0U] , u32SectorCnt))
				{
					USB_CDC_Transmit_Response(USB_CDC_RESP_GET_DB_DATA ,
							(uint8_t*)&m_DB[0U] , MAX_DATA_PER_DATAPUSH_CYCLE * sizeof(DATABASE));
				}
				else
				{
					USB_CDC_Transmit_Response(USB_CDC_RESP_NVM_BUSY , NULL , 0U);
				}
			}
			else
			{
				USB_CDC_Transmit_Response(USB_CDC_RESP_ERR_NOT_IDLE , NULL , 0U);
			}

		}break;
	}
}



