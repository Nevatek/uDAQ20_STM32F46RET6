/*
 * Drv_AD7616.c
 *
 *  Created on: May 18, 2025
 *      Author: aldri
 */
#include "main.h"
#include "Appl_Timer.h"
#include "Drv_AD7616.h"

uint8_t g_u8AdcConvComplteFlag = FALSE;
uint8_t g_u8SPI_WrCmplte = FALSE;
uint8_t g_u8SPI_RdCmplte = FALSE;
uint8_t g_u16SpiReadBuffer[32U];
uint16_t g_u16ADCDataVal[16U];

AD7616_STATE m_State = en_AD7616_IDLE;
AD7616_CHANNEL m_MaxChannelScan = AD7616_CHAB0;
AD7616_CHANNEL m_ChannelSel;
stcTimer g_ADCTim;
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for BUSY interrupt PIN - Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
inline void ISRCallback_Ad7616_Busy(void)
{
	/*
	 * If BUSY pin LOW means , AD7616 starts conversion of SAR , now make CONV signal LOW
	 */
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_RESET);
	/*If BUSY is LOW means , ADC conversion is completed*/
	g_u8AdcConvComplteFlag = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef * hspi)
{
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	g_u8SPI_RdCmplte = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef * hspi)
{
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	g_u8SPI_WrCmplte = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_Init(void)
{
	/*
	 * Perform RESET
	 */
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_SET);
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	Drv_AD7616_SelectChannel(m_MaxChannelScan = AD7616_CHAB1/*MAX Channel to scan*/);/*Sequencer will read from channel 0 - Configured channel*/
	Drv_AD7616_SelectHWInputVoltageRange(RANGE_SEL_PM_2_5V);
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_RESET);

	HAL_Delay(TIME_RESET_WAIT);
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_RESET);

	HAL_Delay(TIME_RESET_WAIT);
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_SET);

	HAL_Delay(TIME_RESET_WAIT);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_DeviceConvCmplte(void)
{
	return g_u8AdcConvComplteFlag;
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_TX_Complete(void)
{
	return g_u8SPI_WrCmplte;
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_RX_Available(void)
{
	return g_u8SPI_RdCmplte;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_SelectChannel(AD7616_CHANNEL m_Ch)
{
	uint8_t u8Channel = (uint8_t)m_Ch;
	HAL_GPIO_WritePin(AD7616_CHSEL2_GPIO_Port, AD7616_CHSEL2_Pin, (u8Channel & 0x01));
	HAL_GPIO_WritePin(AD7616_CHSEL1_GPIO_Port, AD7616_CHSEL1_Pin, 0x01 & (u8Channel >> 1U));
	HAL_GPIO_WritePin(AD7616_CHSEL0_GPIO_Port, AD7616_CHSEL0_Pin, 0x01 & (u8Channel >> 2U));
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_SelectHWInputVoltageRange(HW_RANGE_SEL m_inpVR)
{
	uint8_t u8Buff = (uint8_t)m_inpVR;

	HAL_GPIO_WritePin(AD7616_HW_RNGSEL1_GPIO_Port , AD7616_HW_RNGSEL1_Pin , (u8Buff & 0x01));
	HAL_GPIO_WritePin(AD7616_HW_RNGSEL0_GPIO_Port , AD7616_HW_RNGSEL0_Pin , (0x01 & (u8Buff >> 1U)));
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_TriggerAdcConvst(void)
{
	g_u8AdcConvComplteFlag = FALSE;
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_SET);
}

/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS


 .Note           :
 ****************************************************************************/
void Drv_AD7616_TriggerReadADCSpi_1W(void)
{
	g_u8SPI_RdCmplte = FALSE;
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_RESET);
	HAL_SPI_Receive_IT(GetInstance_SPI1(), &g_u16SpiReadBuffer[0U], 4U*8U/*Read size of bytes*/);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t* Drv_AD7616_ReadSpiADC_1W(void)
{
	return (&g_u16SpiReadBuffer[0U]);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
AD7616_STATE Drv_AD7616_GetState(void)
{
	return (m_State);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_Handler(void)
{
	uint8_t *pBuff = 0U;
	switch (m_State)
	{
		case (en_AD7616_IDLE):
		{
			m_State = en_AD7616_START_OF_CONV;
		}break;

		case (en_AD7616_START_OF_CONV):
		{
			m_ChannelSel = AD7616_CHAB0;/*Inital channel to buffer*/
			Drv_AD7616_TriggerAdcConvst();/*TRIGGER SCAN CONV*/
			StartTimer(&(g_ADCTim) , TIMEOUT_AD7616_BUSY);/*MAX Timeout for BUSY or conversion time*/
			m_State = en_AD7616_WAITING_FOR_BUSY_SIG_FALLING;
		}break;

		case (en_AD7616_WAITING_FOR_BUSY_SIG_FALLING):
		{
			if(TRUE == Drv_AD7616_GetStatus_DeviceConvCmplte())
			{
				/*IF BUSY signal is low (END of converison) -> READ CHANNEL*/
				m_State = en_AD7616_READING_CHANNEL_ENTRY;
			}
			if(TRUE == Timer_IsTimeout(&(g_ADCTim)))
			{
				/*IF Conversion failed after timeout -> GOTO IDLE state*/
				m_State = en_AD7616_IDLE;
			}
		}break;
		case (en_AD7616_WAITING_FOR_BUSY_SIG_FALLING_BUSY):
		{
				m_State = en_AD7616_READING_CHANNEL_ENTRY;
		}break;
		case (en_AD7616_READING_CHANNEL_ENTRY):
		{
			Drv_AD7616_TriggerReadADCSpi_1W();/*Inititate reading*/
			m_State = en_AD7616_READING_CHANNEL;
		}break;
		case (en_AD7616_READING_CHANNEL):
		{
			if(TRUE == Drv_AD7616_GetStatus_RX_Available())
			{
				*pu16ChA = (g_u16SpiReadBuffer[0U]);
				*pu16ChA |= (g_u16SpiReadBuffer[1U] << 8U);


				pBuff = Drv_AD7616_ReadSpiADC_1W();

				for(uint8_t u8Idx = 0U ; u8Idx < 2U * m_MaxChannelScan ; u8Idx += 2U)
				{
					g_u16ADCDataVal[u8Idx] = (pBuff[(u8Idx * 2U) + 0U]);
					g_u16ADCDataVal[u8Idx] = (pBuff[(u8Idx * 2U) + 1U]);
				}

//				m_ChannelSel++;
//				if(m_MaxChannelScan < m_ChannelSel)
//				{
					/*If all channel got readed -> go to complete state*/

					m_State = en_AD7616_READING_CMPLTED;
//				}
//				else
//				{
//					/*IF READING is completed -> SWITCH channel and READ next channel*/
//					m_State = en_AD7616_READING_CHANNEL_ENTRY;
//				}
			}
		}break;
		case (en_AD7616_READING_CMPLTED):
		{
			m_State = en_AD7616_IDLE;
		}break;
	}
}
