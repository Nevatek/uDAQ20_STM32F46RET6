/*
 * Drv_AD7616.c
 *
 *  Created on: May 18, 2025
 *      Author: aldri
 */
#include "main.h"
#include "Appl_Timer.h"
#include "Drv_AD7616.h"

uint8_t g_u8AdcConvComplteFlag = FALSE;
uint8_t g_u8SPI_WrCmplte = FALSE;
uint8_t g_u8SPI_RdCmplte = FALSE;
uint8_t g_u16SpiReadBuffer[8U];
uint16_t g_u16ADCData[2U][8U];

AD7616_STATE m_State = en_AD7616_IDLE;
AD7616_CHANNEL m_ChannelSel = AD7616_CHAB0;
stcTimer g_ADCTim;
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for BUSY interrupt PIN - Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
inline void ISRCallback_Ad7616_Busy(void)
{
	/*
	 * If BUSY pin LOW means , AD7616 starts conversion of SAR , now make CONV signal LOW
	 */
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_RESET);
	/*If BUSY is LOW means , ADC conversion is completed*/
	g_u8AdcConvComplteFlag = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef * hspi)
{
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	g_u8SPI_RdCmplte = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef * hspi)
{
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	g_u8SPI_WrCmplte = TRUE;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_Init(void)
{
	/*
	 * Perform RESET
	 */
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_SET);
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_SET);
	Drv_AD7616_SelectChannel(AD7616_CHAB7);
	Drv_AD7616_SelectHWInputVoltageRange(RANGE_SEL_PM_10V);
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_RESET);

	HAL_Delay(TIME_RESET_WAIT);
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_RESET);

	HAL_Delay(TIME_RESET_WAIT);
	HAL_GPIO_WritePin(AD7616_RESET_GPIO_Port , AD7616_RESET_Pin , GPIO_PIN_SET);

	HAL_Delay(TIME_RESET_WAIT);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_DeviceConvCmplte(void)
{
	return g_u8AdcConvComplteFlag;
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_TX_Complete(void)
{
	return g_u8SPI_WrCmplte;
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
uint8_t Drv_AD7616_GetStatus_RX_Available(void)
{
	return g_u8SPI_RdCmplte;
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_SelectChannel(AD7616_CHANNEL m_Ch)
{
	uint8_t u8Channel = (uint8_t)m_Ch;
	HAL_GPIO_WritePin(AD7616_CHSEL0_GPIO_Port, AD7616_CHSEL0_Pin, (u8Channel & 0x01));
	HAL_GPIO_WritePin(AD7616_CHSEL1_GPIO_Port, AD7616_CHSEL1_Pin, 0x01 & (u8Channel >> 1U));
	HAL_GPIO_WritePin(AD7616_CHSEL2_GPIO_Port, AD7616_CHSEL2_Pin, 0x01 & (u8Channel >> 2U));
}
/*********************.HAL_GPIO_EXTI_Callback().*****************************
 .Purpose        : Callback for GPIO interrupt Rising and falling
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_SelectHWInputVoltageRange(HW_RANGE_SEL m_inpVR)
{
	uint8_t u8Buff = (uint8_t)m_inpVR;

	HAL_GPIO_WritePin(AD7616_HW_RNGSEL1_GPIO_Port , AD7616_HW_RNGSEL1_Pin , (u8Buff & 0x01));
	HAL_GPIO_WritePin(AD7616_HW_RNGSEL0_GPIO_Port , AD7616_HW_RNGSEL0_Pin , (0x01 & (u8Buff >> 1U)));
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_TriggerAdcConvst(void)
{
	g_u8AdcConvComplteFlag = FALSE;
	HAL_GPIO_WritePin(AD7616_CONV_GPIO_Port , AD7616_CONV_Pin , GPIO_PIN_SET);
}

/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_TriggerReadADCSpi_1W(void)
{
	g_u8SPI_RdCmplte = FALSE;
	HAL_GPIO_WritePin(AD7616_CS__GPIO_Port , AD7616_CS__Pin , GPIO_PIN_RESET);
	HAL_SPI_Receive_IT(GetInstance_SPI1(), &g_u16SpiReadBuffer[0U], sizeof(uint32_t));
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_ReadSpiADC_1W(uint16_t *pu16ChA , uint16_t *pu16ChB)
{
	*pu16ChA = (g_u16SpiReadBuffer[1U] << 8U);
	*pu16ChA |= (g_u16SpiReadBuffer[0U]);

	*pu16ChB = (g_u16SpiReadBuffer[3U] << 8U);
	*pu16ChB |= (g_u16SpiReadBuffer[2U]);
}
/*********************.Drv_AD7616_TriggerAdcConvst().*****************************
 .Purpose        : Function to trigger start of converion of ADC
 .Returns        :  RETURN_ERROR
					RETURN_SUCCESS
 .Note           :
 ****************************************************************************/
void Drv_AD7616_Handler(void)
{
	switch (m_State)
	{
		case (en_AD7616_IDLE):
		{
			m_State = en_AD7616_START_OF_CONV;
		}break;

		case (en_AD7616_START_OF_CONV):
		{
			m_ChannelSel = AD7616_CHAB0;
			Drv_AD7616_SelectChannel(AD7616_CHAB1);
			Drv_AD7616_TriggerAdcConvst();
			StartTimer(&(g_ADCTim) , TIMEOUT_AD7616_BUSY);/*MAX Timeout for BUSY or conversion time*/
			m_State = en_AD7616_WAITING_FOR_BUSY_SIG_FALLING;
		}break;

		case (en_AD7616_WAITING_FOR_BUSY_SIG_FALLING):
		{
			if(TRUE == Drv_AD7616_GetStatus_DeviceConvCmplte())
			{
				/*IF BUSY signal is low (END of converison) -> READ CHANNEL*/
				m_State = en_AD7616_READING_CHANNEL_ENTRY;
			}
			if(TRUE == Timer_IsTimeout(&(g_ADCTim)))
			{
				/*IF Conversion failed after timeout -> GOTO IDLE state*/
				m_State = en_AD7616_IDLE;
			}
		}break;
		case (en_AD7616_READING_CHANNEL_ENTRY):
		{
			Drv_AD7616_TriggerReadADCSpi_1W();/*Inititate reading*/
			m_State = en_AD7616_READING_CHANNEL;
		}break;
		case (en_AD7616_READING_CHANNEL):
		{
			if(TRUE == Drv_AD7616_GetStatus_RX_Available())
			{
				Drv_AD7616_ReadSpiADC_1W(&g_u16ADCData[0U][m_ChannelSel] , &g_u16ADCData[1U][m_ChannelSel]);

				m_ChannelSel++;
				if(AD7616_CHMAX <= m_ChannelSel)
				{
					/*If all channel got readed -> go to complete state*/
					m_State = en_AD7616_IDLE;
				}
				else
				{
					/*IF READING is completed -> SWITCH channel and READ next channel*/
					m_State = en_AD7616_READING_CHANNEL_ENTRY;
				}
			}
		}break;
	}
}
